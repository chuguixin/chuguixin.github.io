<!DOCTYPE html><html lang="zh-cmn-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Async JavaScript</title><link rel="stylesheet" href="/css/layout.css" type="text/css">
<link rel="stylesheet" href="/css/main.css" type="text/css"><link rel="shortcut icon" href="/img/favicon.png"></head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">随心小筑</a></li><li class="menu-item"><a href="/blog/archives" class="menu-link">Archives</a></li><li class="menu-item"><a href="/about" class="menu-link">About</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">随心小筑</a></li><li class="menu-item"><a href="/blog/archives" class="menu-link">Archives</a></li><li class="menu-item"><a href="/about" class="menu-link">About</a></li></ul></nav><div id="mobile-menu-toggle" class="toggle-menu"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Async JavaScript</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title">发表于: </span>2014-05-18</p><p class="meta-item meta-category"><span class="meta-item-title">分类于: </span><a href="/blog/categories/JavaScript/" target="_blank" class="category-link">JavaScript</a></p></div><div class="article-content"><p>最近看了一些JavaScript异步编程方面文章，也反复读了几遍薄薄的<a href="http://book.douban.com/subject/24319975/" target="_blank">《Async JavaScript》</a>。总结一下，供自己后续学习使用，并分享给大家。</p>
<p>首先，有几个问题。什么是异步编程/异步函数？异步函数和回调函数有什么关系？为什么异步编程经常与JavaScript同时出现？JavaScript中的异步函数的机制是怎样的？那么现在异步编程有什么解决方案？未来的JavaScript异步编程是什么样子？如果你对上述几个问题已经虽不至“如数家珍”但已是“一目了然”，那么再往下的内容就不适合你了。那么，我们开始吧~</p>
<a id="more"></a>
<h3 id="什么是异步函数？">什么是异步函数？</h3><p>对于一个jser而言，学习和使用JavaScript的过程中，“异步编程”的出现频率应该是极高的，或许仅次于“事件驱动”、“单线程”等等。那么什么异步编程呢？什么是异步函数呢？</p>
<p>言简意赅的说：异步函数就是会导致将来运行<strong>一个取自事件队列的函数</strong>的函数。这里的重点是“取自事件队列”，关于这个概念，我们暂且按下不表，将在后面进行分析，我们现在只需要知道异步函数是会导致将来某个时刻运行另外一个函数的函数。</p>
<h3 id="异步函数_VS_回调函数">异步函数 VS 回调函数</h3><p>又是一个高频词汇，“回调函数”。再次，我觉得有必要区分一下回调函数和异步函数的概念，虽然在很多人看来在这一点上的区分不必太过纠结，可是借用老罗的话，“我不是为了输赢，我就是认真”，对概念的精确理解和把握往往是我们深入学习的第一个台阶。</p>
<p>所谓回调函数：In computer programming, a callback is <strong>a piece of executable code that is passed as an argument to other code</strong>, which is expected to call back (execute) the argument at some convenient time. <strong>The invocation may be immediate as in a synchronous callback or it might happen at later time, as in an asynchronous callback.</strong> In all cases, the intention is to specify a function or subroutine as an entity that is, depending on the language, more or less similar to a variable.(from <a href="http://en.wikipedia.org/wiki/Callback_(computer_programming)" target="_blank">wikipedia</a>)</p>
<p>从wikipedia的说法中我们可以清晰的看到：首先，回调函数是作为参数传入到另外一段代码中的一段可执行代码，也就是它所强调的是回调函数是需要被当做参数传入到其它代码中的；其次，回调函数可以是同步的，也可以是异步的，这取决于使用者。如果我们进入到wikipedia的页面，我们能额外发现一些其它的知识，比如回调函数会出现在拥有某些特性的语言中，那么函数是一等公民的JavaScript当然也就完美支持回调函数了。</p>
<p>那么，现在这两个概念应该比较清晰了，我们举个例子比较一下。比如：<br><figure class="highlight javascript"><figcaption><span>callback VS async function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback executed!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(callbackFunc,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">syncFunc</span>(<span class="params">callbackFunc</span>)</span>&#123;</span><br><span class="line">    callbackFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码片段中，setTimeout是一个异步函数，因为它导致了大约1秒后callbackFunc的运行；而callbackFunc对于setTimeout来说，它是一个回调函数。同时，callbackFunc对于syncFunc来说，它也是一个回调函数，但是被同步执行（在同一个事件循环里被执行），那么syncFunc不能被称为异步函数。</p>
<p>另外，在网上的一些文章中都能看到，很多人将回调函数作为了异步编程的一个解决方案进行总结，包括阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank">Javascript异步编程的4种方法</a>。对于此，我认为这种分类是不太恰当的。如果将回调函数看做异步编程的一种解决方案，那么我们后面讲到的分布式事件、Promise以及强大的工作流控制库都是借助回调函数的形式来实现，岂不是都能看做是同一种解决方案？所以，我认为，回调函数并不能简单地被当做异步编程的一种解决方案。</p>
<h3 id="JavaScript中的异步机制">JavaScript中的异步机制</h3><p>每一个jser都应该了解，JavaScript是单线程的。所谓“单线程”，就是同一时刻只能执行一个任务，或者说只能有一个函数一个代码片段在执行。那么，我们就很容易产生疑问，如果是单线程，那异步是如何实现的？</p>
<p>一句话回答：<strong>事件驱动（event-driven）</strong>。不只是JavaScript，几乎所有的单线程且异步的语言，都是通过event-driven实现的。下面，我希望用最易懂的文字描述清楚事件驱动：</p>
<p>首先，JavaScript是单线程执行的，但是JavaScript引擎的平台（比如浏览器或者nodejs等）是拥有若干线程的。比如，对于一个浏览器而言，有一条线程做渲染，有一条线程记录事件（比如click等），有一条线程执行JavaScript等等，这些线程在浏览器内核的协调控制下执行（比如，JavaScript线程执行期间，不能进行ui渲染）。这是单线程实现异步的基础。</p>
<p>其次，每一个异步函数都会对应至少一个event-handler，而上文中提到的<em>事件队列</em>便是event-handler在被处理的时候存放的地方。JavaScript引擎的线程会在适当的时机处理一系列的event-handler，适当的时机需要满足两个条件：1.该事件已经满足触发条件（比如，setTimeout(func,1000)后大约1000ms）；2.JavaScript的线程空闲（比如，如果setTimeout注册的回调函数延时条件已经满足，但是此时JavaScript引擎正在做一个复杂的for循环耗时3秒，那么setTimeout的回调也只能在上文的for循环执行完成后再去执行）。这里再提到event-loop的存在，每一次循环都是一个tick，它的作用就是不断的循环检测事件队列中是否有event-handler，如果有便会取出执行。我们可以这样理解event-loop：<br><figure class="highlight javascript"><figcaption><span>event-loop</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(atLeastOneEventIsQueued)&#123;</span><br><span class="line">        fireNextQueuedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，事件“满足触发条件”（上文中适当的时机的条件1）是如何判断的？不同的事件的“触发条件”可能由不同的线程监控。比如，我们发送一个ajax请求，应该是浏览器有一个独立的线程发送http请求并在请求返回的时候通知JavaScript引擎线程满足触发条件；而click一个button，应该就是浏览器的GUI线程通知JavaScript引擎然后适时执行相应的event-handler。</p>
<p>我们举个例子说明，假设：我们处于一个页面，这个页面上有一个setTimeout正在执行延时1000ms执行<em>某段代码</em>；而在这个200ms的时候，我们点击了一个按钮，因为此时已经满足事件触发条件，且JavaScript线程空闲，所以按照我们的脚本浏览器会立即执行与这个事件绑定的另外<em>某段代码</em>；点击事件触发的<em>某段代码</em>会做两件事，一件事是注册一个setInterval要求每隔700ms执行<em>某段代码</em>；另一件是发送一个ajax请求，并要求请求返回后执行<em>某段代码</em>，这个请求会在1500ms后返回。在这之后，可能还会有其它的事件被触发。</p>
<p>上文中，每一个“<em>某段代码</em>”都是一个event-handler，而event-handler被触发的时机可能受前面event-handler的影响。我们按照每个event-handler的执行时间都非常短来处理，可以得到如下图所示（上方标示event-handler对应的异步函数，下方标示大致的时间）：</p>
<img src="http://sxxz.u.qiniudn.com/async-javascript-event-driven.png" class="center">
<p>从图中我们能看到事件的执行顺序，这个很容易理解。现在想一下，如果点击事件的event-handler先执行一个while循环执行了100ms，然后再去setInterval和ajax请求，那么执行顺序又是怎样的呢？如果理解了JavaScript的事件驱动机制，这个就很容易了。留一段代码，大家自己尝试一下，是不是跟大家想的一样？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">"num"</span>:<span class="number">1</span>&#125;,start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;obj.num= <span class="number">2</span>;&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span> - start &lt; <span class="number">1000</span>)&#123;&#125;</span><br><span class="line">alert(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure></p>
<p>或许还可以想到我们平时遇到的一些问题背后的原因：</p>
<p>1.为什么大多情况下setInterval执行间隔会小于setTimeout？</p>
<p>2.为什么setTimeout会有最小间隔？<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html" target="_blank" rel="external">whatwg</a>和<a href="http://www.w3.org/TR/2011/WD-html5-20110525/timers.html" target="_blank" rel="external">w3c</a>的HTML5规范都规定4ms。</p>
<p>3.为什么建议将耗时的函数分多次执行？比如，process.nextTick。</p>
<h3 id="JavaScript异步编程解决方案">JavaScript异步编程解决方案</h3><p>现在主要的异步编程的方案有三种：1.PubSub模式（分布式事件）；2.Promise对象；3.工作流控制库。<br>下面，我们将逐个进行分析：<br>在这些异步方案之前，我们经常能看到所谓的“金字塔厄运”：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc1(<span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//some codes</span></span><br><span class="line">    asyncFunc2(<span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//some codes</span></span><br><span class="line">        asyncFunc3(<span class="function"><span class="keyword">function</span>(<span class="params">result3</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//other codes</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>那么，我们的解决方案就是使我们能更加方便的组织异步代码，规避像上面那样的问题。</p>
<h4 id="PubSub模式（分布式事件）">PubSub模式（分布式事件）</h4><p>所谓的PubSub模式其实很简单，比如我们平时使用的<code>dom.addEventListener</code>就是一个PubSub模式最鲜活的例子。在2000年<a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html" target="_blank" rel="external">DOM Level 2</a>发布之前，我们可能需要使用类似于<code>dom.onclick</code>的方式去绑定事件。这样很容易产生问题，比如我们有两个event-handler需要绑定到同一个事件上，如果没有分布式事件的话，我们不能：<br><figure class="highlight javascript"><figcaption><span>onclick</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dom.onclick = eventHandler1;</span><br><span class="line">dom.onclick = eventHandler2;</span><br></pre></td></tr></table></figure></p>
<p>很明显，<code>onclick</code>只是<code>dom</code>的一个属性，同一个key不能对应多个value，第一个会被第二个覆盖掉，所以我们只能：<br><figure class="highlight javascript"><figcaption><span>onclick</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dom.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    eventHandler1.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    eventHandler1.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样的坏处很多，比如不够灵活，代码冗长，不利于维护等等。</p>
<p>现在开始学习前端，可能已经没有老师或者书籍讲解这样的用法了。<code>dom.addEventListener</code>标准化之后，我们可以：<br><figure class="highlight javascript"><figcaption><span>addEventListener</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dom.addEventListener(<span class="string">'click'</span>,eventHandler1);</span><br><span class="line">dom.addEventListener(<span class="string">'click'</span>,eventHandler2);</span><br></pre></td></tr></table></figure></p>
<p>而像jQuery这样的类库，也自然磨平了不同浏览器的差异，提供了类似于<code>$dom.on()</code>的方法。如今，几乎所有的前端dom相关的类库都会提供类似的API。当然，在JavaScript世界的另一端，nodejs也有核心模块<code>Events</code>提供<code>EventEmitter</code>对象，从而很容易实现分布式事件：<br><figure class="highlight javascript"><figcaption><span>EventEmitter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Emitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> Emitter();</span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(stream + <span class="string">'from eventHandler1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(stream + <span class="string">'from eventHandler2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.emit(<span class="string">'someEvent'</span>,<span class="string">'I am a stream!'</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们用DOM举例并不是说明PubSub模式就是事件监听，而是因为事件监听是一个典型的分布式事件的示例，只是我们的订阅和发布依托的对象不是一个常规的对象，而是一个浏览器的DOM对象，而在jQuery中这个对象就是jQuery对象了。下面，我们用最简单的代码实现一个PubSub模式：<br><figure class="highlight javascript"><figcaption><span>PubSub模式简单实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PubSub = &#123;handlers: &#123;&#125;&#125;;</span><br><span class="line">PubSub.sub = <span class="function"><span class="keyword">function</span>(<span class="params">event, handler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers;</span><br><span class="line">    !(event <span class="keyword">in</span> handlers) &amp;&amp; handlers[event] = [];</span><br><span class="line">    handlers[event].push(handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">PubSub.pub = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> handlers = (handlers[event] || []);</span><br><span class="line">    <span class="keyword">var</span> handlerArgs = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,item;item = handlers[i];i++)&#123;</span><br><span class="line">        item.apply(<span class="keyword">this</span>, handlerArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如同我们看到的，上面的代码只是一个最简单甚至不安全的实现。在生产环境中，有很多成熟的框架，比如<a href="https://github.com/mroderick/PubSubJS" target="_blank" rel="external">PubSubJS</a>这样纯粹的PubSub模式的实现。同时，从上面的实现中，我们能发现，所有的event-handler都是同步执行的，这与我们浏览器中真实点击事件的事件处理时机还是有差异的，真实的点击事件的handler会在后续的event-loop中触发，同样，我们手动的<code>dom.click()</code>或者jQuery的<code>$dom.click()</code>都是同步执行的（大家可以测试一下）。</p>
<p>PubSub模式是大家最常用的一种方式，相对容易理解。基于这种事件化对象，实现了代码的分层次化，像大名如雷贯耳的Backbone.js也是使用了这样的技术。这是PubSub模式的好处。但是，事件不是万金油，有一些情况不适合用事件来处理，比如一些一次性转化且只有成功或者失败结果的流程，使用PubSub模式就有一些不合适。而这种情景下，Promise就显得更加适合我们。</p>
<h4 id="Promise对象">Promise对象</h4><p>Promise在很多语言中都有各自的实现，而其与JavaScript的结缘要归功于JavaScript发展历史上有里程碑意义的Dojo框架。2007年Dojo的开发者受Twisted的启发，为Dojo添加了一个dojo.Deferred对象。2009年，Kris Zyp在CommonJS社区提出了<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="external">Promise/A规范</a>。之后，风云变幻，nodejs异军突起（2010年初nodejs放弃了对Promise的原生支持），2011年jQuery1.5携带着“叛逆”的Promise实现以及崭新的ajax风火问世，从此Promise真正被JavaScript开发者所熟知。如今，更多的实现早已关注羽翼更加丰满的<a href="http://promisesaplus.com/" target="_blank" rel="external">Promise/A+规范</a>，jQuery对Promise的实现也对标准有所妥协，同时像<a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q.js</a>的出现也使得JavaScript世界有了通吃客户端和服务器端的直观且纯粹的实现。就在不远的（2014年12月）将来，JavaScript发展史上有一个重大的时刻将会到来，ES6将成为正式标准，在众多夺人眼球的特性中，对<a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-operations-on-promise-objects" target="_blank" rel="external">Promise的原生支持</a>仍然不乏瞩目，如果再配以<a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-generator-function-definitions" target="_blank" rel="external">Generator</a>将是如虎添翼。稍远的将来，ES7会提供一个<code>async</code>关键字引导声明的函数，支持<code>await</code>，而此番花样将会如何让我们拭目以待。</p>
<p>废话一大篇，下面是正餐：</p>
<p>CommonJS社区的<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="external">Promise/A规范</a>相对简洁，而<a href="http://promisesaplus.com/" target="_blank" rel="external">Promise/A+规范</a>规范对其作了一些补充，我们后面将以Promise/A+规范配以实例学习Promise。</p>
<p>什么是Promise？Promise是一个对象，它代表异步函数的返回结果。用代码表示也就是：<br><figure class="highlight javascript"><figcaption><span>Promise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = asyncFunction();</span><br></pre></td></tr></table></figure></p>
<p>如果具象一点，我们常见的一个jQuery的ajax调用就是这样：<br><figure class="highlight javascript"><figcaption><span>$.ajax with promise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajaxPromise = $.ajax(<span class="string">'mydata'</span>);</span><br><span class="line">ajaxPromise.done(successFunction);</span><br><span class="line">ajaxPromise.fail(errorFunction);</span><br><span class="line">ajaxPromise.always(completeFunction);</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中，我们看到jQuery返回的Promise对象拥有若干方法，比如<code>done</code>、<code>fail</code>和<code>always</code>分别对应了ajax成功、失败以及无论成功失败都应该执行的回调，这些方法可以看做是规范之上的具体实现带给我们的语法糖。那么，真实的Promise规范是什么样？（其实，规范相对简短，大家可以稍花时间阅读，在此我们做一下主干介绍）</p>
<p>Promise的状态能且只能是下面三种的某一种：<code>pending</code>, <code>fulfilled</code>, <code>rejected</code>。这三种状态之间的关系：<br><br>    <em>pending</em>:可以转变到fulfilled状态或者rejected状态<br>    <em>fulfilled</em>:不可以转变到其他任何状态，而且必须有一个不可改变的<code>value</code><br>    <em>rejected</em>:不可以转变到其他任何状态，而且必须有一个不可改变的<code>reason</code><br>关于<code>value</code>和<code>reason</code>，我们可以分别理解为<code>fulfilled</code>的结果和<code>rejected</code>的原因。</p>
<p>Promise必须要拥有一个<code>then</code>方法，用以访问当前或者最终的<code>value</code>或<code>reason</code>。<code>then</code>方法拥有两个参数，而且这两个参数都是可选的，用<code>promise.then(onFulfilled, onRejected)</code>分析如下：<br>    <em>onFulfilled</em>:如果不是函数，将被忽略。<br>                  如果是函数，只有且必须在promise状态转换为fulfilled之后被触发一次，并且只传递promise的<code>value</code>作为第一个参数。<br>    <em>onRejected</em>:如果不是函数，将被忽略。<br>                 如果是函数，只有且必须在promise状态转换为rejected之后被触发一次，并且只传递promise的<code>reason</code>作为第一个参数。</p>
<pre><code>另外：多次调用then绑定的回调函数，在<span class="escape">`f</span>ulfilled<span class="escape">`或</span><span class="escape">`r</span>ejected<span class="escape">`的</span>时候，执行顺序与绑定顺序相对应。
      规范要求，调用需要在<span class="escape">`t</span>hen<span class="escape">`之</span>后的event <span class="keyword">loop</span>中执行。
</code></pre><p>Promise的<code>then</code>方法必须返回一个promise对象，以供链式调用，如果onFulfilled或者onRejected有<code>throw</code>，那么后生成的Promise对象应该以抛出内容为<code>reason</code>转化为<code>rejected</code>状态。</p>
<p>在浅析Promise规范之后，我们可以完善一下本章节的第一段代码：<br><figure class="highlight javascript"><figcaption><span>Promise Chain</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = asyncFunction();</span><br><span class="line">promise = promise.then(onFulfilled1, onRejected1)</span><br><span class="line">                 .then(onFulfilled2, onRejected2);</span><br><span class="line"></span><br><span class="line">promise.then(onFulfilled3, onRejected3);</span><br></pre></td></tr></table></figure></p>
<p>Promise/A规范的<a href="http://promisesaplus.com/implementations" target="_blank" rel="external">实现众多</a>，在我们的实际生产中，我们应该选择哪个实现呢？这个只能说因地制宜。<br>比如，当我们在<a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q.js</a>和jQuery之间权衡的时候，大家可以在stackoverflow上找到<a href="http://stackoverflow.com/questions/13610741/use-jquery-or-q-js-for-promises" target="_blank" rel="external">这种</a>。随手贴个之前发的<a href="http://weibo.com/1827726421/B02znb4MS?mod=weibotime" target="_blank" rel="external">weibo</a>。</p>
<p>当然，现在应该有很多人和我一样，期待着ES6的原生Promise实现。ES标准化的Promise看上去是这样的：<br><figure class="highlight javascript"><figcaption><span>Promise Chain</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do a thing, possibly async, then…</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* everything turned out fine */</span>) &#123;</span><br><span class="line">    resolve(<span class="string">"Stuff worked!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="built_in">Error</span>(<span class="string">"It broke"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// "Stuff worked!"</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// Error: "It broke"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们顺带提及一下Generator吧，如果你还不知道Generator是什么？看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="external">这里</a>。简洁一点描述就是Generator函数可以通过特定的<code>yield</code>关键字中断函数执行，并与外界共享执行上下文。Generator函数基于这一特性，可以跟异步函数配合，等待异步函数的执行（结果），然后通过特定的接口（next）将异步结果注入到Generator自己的上下文中，然后继续执行后面的代码。这样结合后，我们便能用同步的方式书写异步代码。能与Generator配合的实现有很多，其中就有Promise对象，而<code>express</code>的主人TJ大神给我们提供了一个非常成熟的方案–<a href="https://github.com/visionmedia/co" target="_blank" rel="external">co</a>。个人感觉，基于Generator优化异步代码的方式会是未来的最受欢迎的方式。在此，推荐几篇比较优秀的文章，我也就不班门弄斧了。朴灵大大的还热乎的<a href="http://www.infoq.com/cn/articles/generator-and-asynchronous-programming" target="_blank" rel="external">Generator与异步编程</a>,不知道是哪位老师的<a href="http://bg.biedalian.com/2013/12/21/harmony-generator.html" target="_blank" rel="external">Harmony Generator, yield, ES6, co框架学习</a>,屈屈大大的<a href="https://www.imququ.com/post/generator-function-in-es6.html" target="_blank" rel="external">ES6中的生成器函数介绍</a>。如果想学习这一“不远未来”的技术，请点击进入上述链接吧。<br>另外，Google和Mozilla分别给了一些自己的解决方案：<a href="https://github.com/google/traceur-compiler" target="_blank" rel="external">traceur</a> 和 <a href="http://taskjs.org/" target="_blank" rel="external">taskjs</a>。</p>
<p>基于Promise，我们可以实现各种串行并行的异步操作，但是，这个串行并行的控制，需要我们手动去维护，而flow-control类的方案，恰恰满足了我们这方面的需求，下面我们就从这里说起吧。</p>
<h4 id="工作流控制库">工作流控制库</h4><p>所谓的工作流控制库（flow-control），我用自己的语言描述便是通过固有的模式（库提供相关的api）组织任务（代码/函数）的执行，从而轻松实现并行串行等需求。那么，比如我们有一个需求，需要读取三个文件，而三个文件是有顺序依赖关系的，那么我们需要做的就是顺序读取，可能代码原始是这样的：<br><figure class="highlight javascript"><figcaption><span>fs.readFile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'originalFile'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data1</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data1,<span class="function"><span class="keyword">function</span>(<span class="params">err,data2</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data2,<span class="function"><span class="keyword">function</span>(<span class="params">err,data3</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//operate with data3</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们看到了一个“美丽的”金字塔。那么，如果用久负盛名的<a href="https://github.com/caolan/async" target="_blank" rel="external">async</a>后，会是怎么样呢？<br><figure class="highlight javascript"><figcaption><span>async.waterfall</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'originalFile'</span>,cb);</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data1,cb</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data1,cb);</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data2,cb</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data2,cb);</span><br><span class="line">  &#125;</span><br><span class="line">],<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//result now equals data3 &amp; operate with data3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>而同样的需求，用极简主义的<a href="https://github.com/creationix/step" target="_blank" rel="external">step</a>实现，代码又是如何呢？<br><figure class="highlight javascript"><figcaption><span>step</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'originalFile'</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,data1</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data1,<span class="keyword">this</span>);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,data2</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data2,<span class="keyword">this</span>);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,data3</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//operate with data3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>关于原始方案异步函数嵌套异步函数，我们可以一目了然就不做解释了。下面，我们对比一下async和step两者：<br>最明显的区别便是，async对外暴露一个对象，对象之下有实现若干特定流程的api。比如，我们需求中，由上而下有顺序依赖关系，async会给我们提供一个很文艺的api叫<code>waterfall</code>,而没有依赖关系只有顺序要求，我们就可以使用<code>async.series</code>,并行推进任务可以用<code>async.parallel</code>等等。相比async，step就显得简洁很多，step给我们只提供了一个函数，它接受一个系列函数作为参数，并根据函数中对<code>this</code>的调用区分实现不同类型的流程控制。上面的示例中，异步函数在完成之后将结果传入step的回调函数执行时的<code>this</code>（如你所想，这时候<code>this</code>是一个函数）,而正是通过<code>this</code>实现了将异步操作的结果传入到下一个step的回调函数，从而实现流程控制。通过<code>this</code>，我们实现其它的流程控制，比如要求多个任务并行：<br><figure class="highlight javascript"><figcaption><span>step parallel</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Step(<span class="function"><span class="keyword">function</span> <span class="title">loadStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file-1'</span>, <span class="keyword">this</span>.parallel());</span><br><span class="line">    fs.readFile(<span class="string">'file-2'</span>, <span class="keyword">this</span>.parallel());</span><br><span class="line">    fs.readFile(<span class="string">'file-3'</span>, <span class="keyword">this</span>.parallel());</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span> <span class="title">showStuff</span>(<span class="params">err, f1, f2, f3</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//operate with f1, f2, f3</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>另外，async还为我们提供了一些流程控制之外的非常易用集合操作的方法以及一些工具函数。比如，类似于数组的map操作，我们看下面的函数：<br><figure class="highlight javascript"><figcaption><span>step parallel</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.map([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.stat, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// results is now an array of stats for each file</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>而当我们需要用step实现类似需求的时候怎么办呢？因为step是极简主义，源码也总共寥寥百余行，但是，我们完全可以借助既有的函数和方法，模拟出一个<code>stepMap</code>:<br><figure class="highlight javascript"><figcaption><span>stepMap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepMap</span>(<span class="params">arr, iterator, callback</span>)</span>&#123;</span><br><span class="line">  step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> group = <span class="keyword">this</span>.group();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++)&#123;</span><br><span class="line">      iterator(arr[i], group());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总之，关于这一类型的解决方案，async和step是两个比较大众的实现，哪个更优，我觉得各有利弊，就像我们权衡express和connect一样。如果你喜欢便捷易用，又对api天生敏感，async是不错的选择；如果你像我一样，喜欢简洁，而且喜欢自己折腾，又不想死记api，那不妨尝试一下step。</p>
<h3 id="结束">结束</h3><p>这算是第一次认真写技术博客，没想到写了这么长，或许里面掺杂了太多废话，或许深浅难易没有控制好，或许还有遗憾，比如Generator在异步编程中的使用可能需要将来单独写一篇，或许值得庆幸，用文字梳理一遍，自己做到“温故知新”。最后，还请各位看官不吝赐教，烦请斧正。</p>
</div><div id="article-discus"><div id="uyan_frame"></div></div></article></div></div><footer class="base-footer"><div class="footer-wrapper"><span>随心 Using </span><a href="https://github.com/chuguixin/Simple"><span>Simple</span></a><span> Presents For You.</span></div></footer><div class="dom-ready"><script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js" type="text/javascript"></script><script src="/js/base.js" type="text/javascript"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?34f1b5ac0025caf0dec6d5dadadeff67";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script src="http://v2.uyan.cc/code/uyan.js?uid=1839078"></script></div></body></html>