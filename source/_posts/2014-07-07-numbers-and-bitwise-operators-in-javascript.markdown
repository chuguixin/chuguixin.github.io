---
layout: post
title: "从机器码到JavaScript中的Numbers和Bitwise operators"
date: 2014-07-07 17:59
comments: true
categories: JavaScript
---

Mozilla开发者社区是我学习的重要途径，有一次逛到<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill" target="_blank">这个API</a>看到Polyfill有几行代码：

```javascript The Unsigned Right Shift Operator
var list = Object(this);
var length = list.length >>> 0;
```

由于非CS的某野生专业出身，我对位运算符号的了解比较模糊，大概能明白的只是`list.length >>> 0`对`list.length`做无符号右移，而返回值是`>=`的整数，但背后的运算过程，就不能说得清楚了。复习了一下相关知识，做个笔记。

<!-- more -->

当下，计算机如此普及，我相信，即使非程序员也了解：计算机的世界只有0和1。而一个程序员应该了解：0/1组成的东西叫机器码，有原码, 反码, 补码等。而一个JS程序员应该了解：JS中的数字是不分类型的，也就是没有byte/int/float/double等的差异。而一个稍微研究ES规范的JS程序员应该了解：JS的number是IEEE 754标准下64-bits的双精度数值，而且ES中有ToInteger/ToInt32/ToUint32/ToUint16等`Type Conversion`。下面，我们就尝试着讨论一下这些。

从硬件的角度上讲，维护两个状态是相对容易的，比如一个二极管的导通或者截止，一个电脉冲的高或者低，从而在实现集成电路时候可以更加简单高效，所以计算机普遍使用0和1来存储和计算。那么，只有0和1，如何表示1234567890呢？这就涉及到`机器码`和`真值`。

###机器码和真值
所谓`机器码`是指，整数在计算机中二进制形式。规则很简单，机器码的最高位（左第一位）表示数字的正负，0表示正数，1表示负数，其余位按照进制转换的规则表示具体数字。

所谓`真值`是指，机器码按照上述转换规则还原的带有正负的实际整数。

举例而言，用8bits表示一个整数，则十进制的整数`+6`可表示为：`00000110`；十进制的数字`-5`可表示为`10000101`。这里说的`+6`和`-5`便是`真值`，而表示它们的二进制数便是`机器码`。再次注意，最高位只用于表示正负，比如`10000101`的真值是`-5`而非`133`，以及我们关于机器码和真值的讨论是基于整数范围的，浮点数在计算机中的存储方式与整数有很大差值，将另作讨论。

有了机器码，我们便可以在计算机中使用机器码存储和计算真值，那么机器码在计算机中是如何计算的呢？

###原码、反码、补码
机器码分为多种，主要包括`原码`、`反码`、`补码`、`移码`等，今天我们主要总结一下前三个，而`移码`非常简单，且多用于比较，不做详细说明。另外需要补充一点，我们在此区分机器码的这么多种形式，主要是针对的有符号数，而无符号数，不需要使用最高位来表示正负，也就不需要这么多种编码方式。

#####原码：
最高位表示正负，其它位表示真值的绝对值。

比如，同样以8bits长度的数串表示`+7`的原码为`0000 0111`，`-7`的原码为`10000111`。以后，我们会这样表示：
```javascript
[+7] = [00000111]原
[-7] = [10000111]原
```
很明显，8bits的原码能记录的范围为：[-127,+127].

原码的好处在于，易于理解，相对直观，方便人脑识别和计算。

对于原码，我们直接计算出其真值然后可以进行后续操作。**但对于计算机，首先，因为最高位用于表示正负，所以不能直接参加运算，需要识别然后做特殊处理；其次，具体计算使用绝对值进行操作，所以两个操作数正负的异同会影响操作符，比如两个异号相加实际要做减法操作，甚至异号相减还需要判断绝对值大小然后决定结果正负。如此，我们计算机的运算器设计将会变得异常复杂。下面，我们将了解如何使用反码和补码将符号位参与运算，从而使加减法统一简单高效地处理，这也是反码和补码出现的原因。**

#####反码：
正数的反码等于其原码，而负数的反码则是对其原码进行`符号位不变，其它位逐一取反`的结果。

比如，同样以8bits长度的数串表示`+7`，那么有如下：
```javascript
[+7] = [00000111]原 = [00000111]反
[-7] = [10000111]原 = [11111000]反
```
同样，8bits的反码能记录的范围为：[-127,+127]。

在按位取反之后，我们可以有下面的操作：
```javascript
2 - 3 = 2 + (-3) 
      = [00000010]原 + [10000011]原 
      = [00000010]反 + [11111100]反 
      = [11111110]反 = [10000001]原 
      = -1
```
上面，我们将减法通过反码转化为了加法，如此，我们的运算将会简单很多，但是反码的方式同样存在一些问题：
```javascript
3 - 3 = 3 + (-3) 
      = [00000011]原 + [10000011]原 
      = [00000011]反 + [11111100]反 
      = [11111111]反 
      = [10000000]原 
      = -0
```
出现了`-0`，这个值是没有意义的。另外，**按照反码加法法则，如果最高位有进位，需要在最低位上`+1`**，那么会出现：
```javascript
3 - 2 = 3 + (-2) 
      = [00000011]原 + [10000010]原 
      = [00000011]反 + [11111101]反 (这里最高位有进位，需要在最低位+1) 
      = [00000001]反 
      = [00000001]原 = 1
```
这种情况，又增加了反码运算的复杂性，影响效率，未解决上面的问题，出现了补码。

#####补码：
正数的反码等于其原码，而负数的补码则是对其反码进行`末位加1`的结果。

比如，再同样以8bits长度的数串表示`+7`，那么有如下：
```javascript
[+7] = [00000111]原 = [00000111]反 = [00000111]补
[-7] = [10000111]原 = [11111000]反 = [11111001]补
```

使用补码，继续做之前的操作：
```javascript 
2 - 3 = 2 + (-3) 
      = [00000010]原 + [10000011]原 
      = [00000010]反 + [11111100]反 
      = [00000010]补 + [11111101]补 
      = [11111111]补 
      = [11111110]反 
      = [10000001]原 
      = -1
```

那么，如果是`3-3`呢？
```javascript
3 - 3 = 3 + (-3) 
      = [00000011]原 + [10000011]原 
      = [00000011]反 + [11111100]反 
      = [00000011]补 + [11111101]补 
      = [00000000]补 
      = [00000000]原 
      = 0
```

是否还需要做额外的加法操作？
```javascript
3 - 2 = 3 + (-2) 
      = [00000011]原 + [10000010]原 
      = [00000011]反 + [11111101]反 
      = [00000011]补 + [11111110]补 
      = [00000001]补 
      = [00000001]原 
      = 1
```

这样，我们便可以完美的将减法统一到加法之上，而且不需要繁琐的正负判断，进位控制，甚至可以节约一个位置。那么，这个位置，也就是`10000000`如何处理呢？按照规定，`10000000`用来表示`-128`，正数的补码/反码/原码相同，而负数的补码只是占用了`-0`的`[10000000]原`和`[11111111]反`转换后得到的`[10000000]补`表示`-128`，但是这个只是帮助理解，不能反向回推得到`-128`的原码和补码。

所以，8bits的补码能记录的范围为：[-128,+127]。

至此，我们已经了解了，计算机中主要使用的存储和计算整数的方式，鉴于现代计算机主要使用补码方式，自然能很容易理解各种数字类型的表示范围，比如32bits的int范围为：[-2<sup>31</sup>,2<sup>31</sup>-1]。这对于我们后面理解一些JavaScript中的极端情况至关重要。

#####稍加补充：
我们可能会想，原码很容易接受的，可是反码和补码的出现是基于什么样的逻辑或者数学原理呢？这里，我们可以蜻蜓点水地讨论一下，因为这个tread已经超出今天话题有点多了。

常用来说明这个原理的例子是时钟，时钟的一周有12个数字，那么，如果我们希望从`3`调整到`8`该如何操作？可以`往前+5`，也可以`往后-7`。这里的两个数字，`+5`和`-7`存在着的关系：它们同时对数字12求余数得到同样的结果。严格的概念是我们小时候学习的`同余`，准确的描述上面的关系是`+5`和`-7`对`模12`同余，`+5`和`-7`是互补关系，互为`补码`。我们可以看出，在`模`的数字范围之内，我们减去一个数字，恰好等于加上这个数字的补码然后取余。大致就这么描述一下，详细的过程是需要严谨的科学证明，网上有大量的文献，在此我们适时收住点到为止，有兴趣的同学自行google吧。

###JavaScript中的数字
作为一个JavaScript程序员，我们只有一个`Number`，所以我们从一开始就习惯了：
```javascript
var num1 = 123;
var num2 = 1.23;
```
但是，你知道JS的number是[IEEE 754标准](http://zh.wikipedia.org/wiki/IEEE_754)的64-bits的双精度数值吗？这是一个什么样的标准？使用这个标准的64-bits双精度意味着什么？下面，我将尝试言简意赅地说明一下这个标准，从而使我们能更懂JavaScript中的数字。

对于计算机而言，数字没有小数和整数的差别，也就是计算机中没有`小数点`的存在。通过前文的讨论，我们已经找到了很完美的整数存储计算的方案，但是当涉及到小数，我们很容易发现，现有的方案无法解决我们的需求。然后，计算机科学家们便尝试了多种方案，主要便是`定点数`和`浮点数`两种。

所谓定点数，是指小数点位置固定在数串中间的某个特定位置，点两侧分别为数字的整数和小数部分。比如用8-bits字长的数串，小数点固定在正中间位置，那么`11001001`和`00110101`分别表示1100.1001和11.0101两个数字。这种方案简单直观易理解，但是存在严重的空间浪费，以及容易溢出的问题。

所谓浮点数，是指小数点的位置是不固定的，通过科学计数法(这个应该不需要解释吧)的方式控制小数点的位置，表示不同的数字。这个表示方案便是`IEEE 754标准`使用的方案，下面我们将主要讨论一下此方案。

现在，让我们想一下小时候学习的科学计数法，比如`-123.456`这个数字，转换成科学计数法应该是：`-1.23456 × 10^2`。这里面已经包含了`IEEE 754标准`的主要元素。我们梳理一下：第一个，自然是正负号的问题，需要一个标志；然后，需要一个具体的数字，表示有效数字或者精度，如上例的`1.23456`；再然后，需要一个控制小数点位置的数字，如上例的`10^2`，回忆一下，我们学习科学计数法的时候，要求前面的数字的绝对值大于1而小于10，也就是小于`10^2`中的`10`，所以这里起决定作用的是指数，也就是上例中的`2`。那么，有了这三个元素，我们便可以很轻松的表示出一个数字，并且灵活的调节小数点位置从而控制数字大小。

上面的要素，转换成标准语言描述，我们称表示正负的标志叫`符号(Sign)`，表示精度的数字为`尾数(Mantissa)`或者`有效数字(Significand)`，而控制小数点位置的指数就叫`指数(Exponent)`，指数和`基数(Base)`共同作用参与计算。下图取自wikipedia，我们直观地感受下这三个要素在一个数串中的相对关系（fraction即等同于前面说的有效数字）：

{% img center http://sxxz.u.qiniudn.com/jiqima-javascript-1.png %}

了解最基本的原理后，我们来大致看一下`IEEE 754标准`做了什么。

首先做的事情就是规定这三个要素在一个数串中占有的位数，试想一下，如果各个实现的位数不确定，那么我们是不是很难正确的还原出原始数字？`IEEE 754标准`规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80比特实做）。只有32位模式有强制要求，其他都是选择性的。而现在主流的语言，多提供了单精度和双精度的实现，我们在此主要比较一下这两者，如图是它们各个部分对应上图，所使用的位数如下：

{% img center http://sxxz.u.qiniudn.com/jiqima-javascript-3.jpg %}

补充一点的是，无论是科学计数法还是标准的规定，都要求有效数字（不考虑符号位）必须`>=1` && `<Base`。所以，有效数字其实一个定点数，小数点的位置固定在有效数字域的最高位和次高位之间。那么，按照上述规定，在二进制中，最高位只能是`1`，所以标准要求省略其最高位，于是精度提高一位。比如，32-bits的单精度有效数字区域只有23位，但是精度却是24位；64-bits的双精度，拥有52位的有效数字域却是54位精度的。

然后，试想一下，如果按照先有的约定，是不是无法表示小于1的实数？因为，指数一定`>=0`，有效数字一定`>1`。于是，`IEEE 754标准`提出了一个很重要的`指数偏移值`。它是说明指数域(Exponent占用的区域)的编码值为指数的实际值加上某个固定的值，换言之便是，如果我们根据指数域计算出的指数是N，那么参与计算实际浮点数的指数应该是`N-指数偏移值`。根据IEEE 754标准的规定，该固定值为`2^(e-1) - 1`，其中的`e`为存储指数的比特的长度。比如，从上图中我们看到，32-bits的单精度是以8-bits表示一个指数域，那么偏移值应该是`2^(8-1) - 1 = 128−1 = 127`。所以，容易得出，单精度浮点数的指数部分实际取值是[-127,128]。如果，某个32-bits单精度的指数为十进制的`1`，那么指数域的编码应该是`10000001`，这个很前面将的机器码有恰好相反，正数的最高位都是`1`。

如开篇所言，JavaScript使用的是
，毫无疑问`Sign`只需要1位，而`Exponent`和`Mantissa`的位数不同影响了精度的范围和小数点移动的范围（也就是最大最小值）

